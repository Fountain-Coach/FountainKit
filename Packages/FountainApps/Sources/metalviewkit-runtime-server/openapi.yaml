openapi: 3.1.0
info:
  title: MetalViewKit Realtime Runtime API
  version: 0.2.0
  summary: Platform-neutral realtime runtime with MIDI 2.0, audio, video, deterministic testing, and a thin hardware audio adapter.
  description: |
    Authoritative spec for the MetalViewKit Realtime Runtime. This API is intended for a local
    or sidecar process that manages a realtime engine (clock, MIDI 2.0, audio, video) and provides
    deterministic test hooks. Edit this curated spec first; server targets consume it via a local
    openapi.yaml that $ref's to this file.
servers:
  - url: http://localhost:7777
    description: Local development server (process-local or container sidecar).
paths:
  /health:
    get:
      operationId: getHealth
      summary: Health probe
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  status: { type: string, enum: [ok] }
                  uptimeSec: { type: number }

  /v1/sessions:
    post:
      summary: Create a runtime session
      operationId: createSession
      tags: [sessions]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/SessionCreate' }
      responses:
        '201': { description: Created, content: { application/json: { schema: { $ref: '#/components/schemas/Session' } } } }

  /v1/sessions/{id}:
    parameters: [ { $ref: '#/components/parameters/SessionId' } ]
    get:
      operationId: getSession
      tags: [sessions]
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/Session' } } } }
    delete:
      operationId: deleteSession
      tags: [sessions]
      responses: { '204': { description: Deleted } }

  /v1/clock:
    get:
      operationId: getClock
      tags: [clock]
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/ClockNow' } } } }

  /v1/clock/test/enable:
    post:
      operationId: enableTestClock
      tags: [clock, test]
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                startNs: { $ref: '#/components/schemas/TimestampNs' }
      responses: { '204': { description: Enabled } }

  /v1/clock/test/advance:
    post:
      operationId: advanceTestClock
      tags: [clock, test]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [deltaNs]
              properties:
                deltaNs: { $ref: '#/components/schemas/DurationNs' }
                steps: { type: integer, minimum: 1 }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/ClockNow' } } } }

  /v1/midi/endpoints:
    get:
      operationId: listMidiEndpoints
      tags: [midi]
      responses:
        '200': { description: OK, content: { application/json: { schema: { type: array, items: { $ref: '#/components/schemas/MidiEndpoint' } } } } }
    post:
      operationId: createMidiEndpoint
      tags: [midi]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/MidiEndpointCreate' }
      responses:
        '201': { description: Created, content: { application/json: { schema: { $ref: '#/components/schemas/MidiEndpoint' } } } }

  /v1/midi/events:
    post:
      operationId: injectMidiEvents
      tags: [midi]
      parameters:
        - in: query
          name: targetDisplayName
          required: false
          schema: { type: string }
          description: Forward UMP to the instrument whose display name contains this substring.
        - in: query
          name: targetInstanceId
          required: false
          schema: { type: string }
          description: Forward UMP to the instrument with this MVK instanceId.
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/MidiInBatch' }
      responses: { '202': { description: Accepted } }
  /v1/midi/vendor:
    post:
      operationId: sendVendor
      tags: [midi]
      parameters:
        - in: query
          name: targetDisplayName
          required: false
          schema: { type: string }
          description: Forward to instrument whose display name contains this substring.
        - in: query
          name: targetInstanceId
          required: false
          schema: { type: string }
          description: Forward to instrument with this MVK instanceId.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [topic]
              properties:
                topic: { type: string }
                data: { type: object }
      responses: { '202': { description: Accepted } }
    get:
      operationId: readMidiEvents
      tags: [midi]
      parameters:
        - in: query
          name: sinceNs
          schema: { $ref: '#/components/schemas/TimestampNs' }
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, maximum: 10000, default: 512 }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/MidiOutBatch' } } } }

  /v1/audio/render:
    post:
      operationId: renderAudio
      tags: [audio, test]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/AudioRenderRequest' }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/AudioRenderResponse' } } } }

  /v1/video/tick:
    post:
      operationId: videoTick
      tags: [video, test]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                frameIndex: { type: integer, minimum: 0 }
                tNs: { $ref: '#/components/schemas/TimestampNs' }
      responses: { '204': { description: Accepted } }

  /v1/faults/model:
    post:
      operationId: setFaultModel
      tags: [faults]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/FaultModel' }
      responses: { '204': { description: Applied } }

  /v1/test/scenario:
    post:
      operationId: loadTestScenario
      tags: [test]
      requestBody:
        content:
          application/json:
            schema: { $ref: '#/components/schemas/TestScenario' }
      responses: { '204': { description: Loaded } }

  /v1/metrics:
    get:
      operationId: getMetrics
      tags: [metrics]
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/Metrics' } } } }

  /v1/tracing/stream:
    get:
      operationId: tracingStream
      tags: [tracing]
      description: |
        Upgrades to a WebSocket connection that emits periodic JSON text frames. The initial frame is a
        JSON array of TraceEvent objects; subsequent frames repeat that array as a heartbeat.
      x-ws-message:
        initial:
          type: array
          items: { $ref: '#/components/schemas/TraceEvent' }
      responses: { '101': { description: WebSocket established } }

  /v1/tracing/dump:
    get:
      operationId: tracingDump
      tags: [tracing]
      responses:
        '200': { description: OK, content: { application/json: { schema: { type: array, items: { $ref: '#/components/schemas/TraceEvent' } } } } }
  /v1/tracing/sse:
    get:
      tags: [tracing]
      summary: Live tracing Server-Sent Events (SSE)
      description: Emits SSE events with JSON-encoded TraceEvent objects.
      responses:
        '200':
          description: OK (SSE stream)
          content:
            text/event-stream:
              schema: { type: string }

  /v1/audio/backend:
    get:
      operationId: getAudioBackendStatus
      tags: [audio-backend]
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/AudioBackendStatus' } } } }
    patch:
      operationId: patchAudioBackendPolicy
      tags: [audio-backend]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/AudioBackendPolicy' }
      responses: { '204': { description: Updated } }

  /v1/audio/devices:
    get:
      operationId: listAudioDevices
      tags: [audio-backend]
      parameters:
        - in: query
          name: scope
          schema: { type: string, enum: [output, input, duplex], default: output }
      responses:
        '200': { description: OK, content: { application/json: { schema: { type: array, items: { $ref: '#/components/schemas/AudioDeviceInfo' } } } } }

  /v1/audio/devices/{id}/open:
    parameters: [ { $ref: '#/components/parameters/DeviceId' } ]
    post:
      operationId: openAudioDevice
      tags: [audio-backend]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/StreamNegotiation' }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/StreamConfig' } } } }

  /v1/audio/stream/start:
    post:
      operationId: startAudioStream
      tags: [audio-backend]
      responses: { '204': { description: Started } }

  /v1/audio/stream/stop:
    post:
      operationId: stopAudioStream
      tags: [audio-backend]
      responses: { '204': { description: Stopped } }

  /v1/audio/stream/stats:
    get:
      operationId: getAudioStreamStats
      tags: [audio-backend]
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/IOStats' } } } }

  /v1/audio/backend/events:
    get:
      operationId: audioBackendEvents
      tags: [audio-backend, tracing]
      description: WebSocket that emits backend status messages as periodic JSON text frames.
      x-ws-message:
        example: { $ref: '#/components/schemas/AudioBackendStatus' }
      responses: { '101': { description: WebSocket established } }
  /v1/audio/backend/events-sse:
    get:
      tags: [audio-backend, tracing]
      summary: Backend events Server-Sent Events (SSE)
      description: Emits SSE events with JSON-encoded backend status objects.
      responses:
        '200':
          description: OK (SSE stream)
          content:
            text/event-stream:
              schema: { type: string }

components:
  parameters:
    SessionId:
      name: id
      in: path
      required: true
      schema: { type: string, format: uuid }
    DeviceId:
      name: id
      in: path
      required: true
      schema: { type: string }

  schemas:
    ClockNow:
      type: object
      properties:
        nowNs: { $ref: '#/components/schemas/TimestampNs' }
        mode: { type: string, enum: [system, test] }
      required: [nowNs, mode]
    TimestampNs:
      type: string
      pattern: '^[0-9]+$'
      description: Unsigned integer nanoseconds since a monotonic epoch.
    DurationNs:
      type: string
      pattern: '^[0-9]+$'
      description: Unsigned integer duration in nanoseconds.

    AudioBackend:
      type: string
      enum: [coreaudio, sdl2, alsa, wasapi, null]

    SessionCreate:
      type: object
      properties:
        sampleRate: { type: number, format: float, default: 48000 }
        audioBlockFrames: { type: integer, enum: [64, 96, 128, 256, 512], default: 128 }
        refreshRateHz: { type: number, format: float, default: 60 }
        midiGroups: { type: integer, minimum: 1, maximum: 16, default: 4 }
        lookaheadNs: { $ref: '#/components/schemas/DurationNs' }
        traceBufferLen: { type: integer, default: 65536 }
        backend: { $ref: '#/components/schemas/AudioBackend' }
      required: [sampleRate, audioBlockFrames]

    Session:
      type: object
      properties:
        id: { type: string, format: uuid }
        config: { $ref: '#/components/schemas/SessionCreate' }
        state: { type: string, enum: [running, stopped] }

    MidiEndpointCreate:
      type: object
      properties:
        name: { type: string }
        direction: { type: string, enum: [input, output] }
        groups: { type: integer, minimum: 1, maximum: 16, default: 1 }
        jrTimestampSupport: { type: boolean, default: true }
      required: [name, direction]

    MidiEndpoint:
      allOf:
        - $ref: '#/components/schemas/MidiEndpointCreate'
        - type: object
          properties:
            id: { type: string, format: uuid }

    UMPWord:
      type: integer
      format: uint32
      minimum: 0
      maximum: 4294967295

    UMPPacket:
      type: object
      properties:
        w0: { $ref: '#/components/schemas/UMPWord' }
        w1: { $ref: '#/components/schemas/UMPWord' }
        w2: { $ref: '#/components/schemas/UMPWord' }
        w3: { $ref: '#/components/schemas/UMPWord' }
      required: [w0]

    MidiEvent:
      type: object
      properties:
        tNs: { $ref: '#/components/schemas/TimestampNs' }
        packet: { $ref: '#/components/schemas/UMPPacket' }
        sourceEndpointId: { type: string, format: uuid, nullable: true }
      required: [tNs, packet]

    MidiInBatch:
      type: object
      properties:
        timeDomain: { type: string, enum: [absoluteNs, relativeToNow], default: absoluteNs }
        events: { type: array, items: { $ref: '#/components/schemas/MidiEvent' } }
      required: [events]

    MidiOutBatch:
      type: object
      properties:
        events: { type: array, items: { $ref: '#/components/schemas/MidiEvent' } }

    AudioRenderRequest:
      type: object
      properties:
        frames: { type: integer, minimum: 1 }
        channels: { type: integer, enum: [1, 2], default: 2 }
        sampleRate: { type: number, format: float, default: 48000 }
      required: [frames]

    AudioRenderResponse:
      type: object
      properties:
        pcm: { type: array, items: { type: number, format: float } }
        frames: { type: integer }
        channels: { type: integer }
        sampleRate: { type: number, format: float }

    FaultModel:
      type: object
      properties:
        midiJitterNs: { $ref: '#/components/schemas/DurationNs' }
        midiDropRate: { type: number, minimum: 0, maximum: 1 }
        audioCallbackStallProb: { type: number, minimum: 0, maximum: 1 }
        masterClockDriftPpm: { type: number }

    TestScenario:
      type: object
      properties:
        description: { type: string }
        steps: { type: array, items: { type: object } }

    Metrics:
      type: object
      properties:
        underruns: { type: integer }
        midiDrops: { type: integer }
        callbackAvgMs: { type: number }
        callbackP99Ms: { type: number }

    TraceEvent:
      type: object
      properties:
        type: { type: string }
        tNs: { $ref: '#/components/schemas/TimestampNs' }
        detail: { type: object }

    AudioBackendStatus:
      type: object
      properties:
        backend: { $ref: '#/components/schemas/AudioBackend' }
        streaming: { type: boolean }
        deviceId: { type: string }
        sampleRate: { type: number, format: float }
        blockFrames: { type: integer }

    AudioBackendPolicy:
      type: object
      properties:
        preferredBackend: { $ref: '#/components/schemas/AudioBackend' }
        allowFormatFallback: { type: boolean, default: true }

    AudioDeviceInfo:
      type: object
      properties:
        id: { type: string }
        name: { type: string }
        rates: { type: array, items: { type: number, format: float } }
        blockSizes: { type: array, items: { type: integer } }
        latencyMs: { type: number }

    StreamNegotiation:
      type: object
      properties:
        desiredSampleRate: { type: number, format: float }
        desiredBlockFrames: { type: integer }
        channels: { type: integer, enum: [1, 2], default: 2 }
        allowFormatFallback: { type: boolean, default: true }

    StreamConfig:
      type: object
      properties:
        deviceId: { type: string }
        sampleRate: { type: number, format: float }
        blockFrames: { type: integer }
        channels: { type: integer }

    IOStats:
      type: object
      properties:
        callbacks: { type: integer }
        underruns: { type: integer }
        avgMs: { type: number }
        p99Ms: { type: number }
