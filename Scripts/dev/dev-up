#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<USAGE
Usage:
  $(basename "$0") [env|prebuild] [--all] [--check] [--patchbay-only] [--host-only] [--no-prebuild] [--robot]

Commands:
  env       Export LAUNCHER_SIGNATURE into current shell (when sourced)
  prebuild  Compile required server binaries up-front (fast boot)

Options:
  --all            Start optional extras (semantic-browser, tools-factory, tool-server, publishing-frontend)
  --check          Wait for readiness on common endpoints (timeout ~30s per service)
  --patchbay-only  Fast profile: start MIDI + PatchBay only (service + UI); skip other servers
  --host-only      Fastest: start agent-host only (BLE central, RTP) and exit
  --no-prebuild    Skip initial prebuild compilation phase
  --robot         After --check, run robot tests subset (fast)
USAGE
}

# Determine repo root
REPO_ROOT=$(cd "$(dirname "${BASH_SOURCE[0]}")"/../.. && pwd)
LOG_DIR="$REPO_ROOT/.fountain/logs"
PID_DIR="$REPO_ROOT/.fountain/pids"
mkdir -p "$LOG_DIR" "$PID_DIR"

# Use existing signature if provided, else fall back to embedded default
DEFAULT_SIG="B86D7CEE-24C4-4C4C-A107-8D0542D1965B"
SIG="${LAUNCHER_SIGNATURE:-$DEFAULT_SIG}"

if [[ "${1:-}" == "env" ]]; then
  # If sourced, export into caller's shell
  if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    export LAUNCHER_SIGNATURE="$SIG"
    echo "[dev-up] Exported LAUNCHER_SIGNATURE=$LAUNCHER_SIGNATURE"
    return 0
  else
    echo "[dev-up] Tip: run 'source Scripts/dev/dev-up env' to export into current shell"
    exit 0
  fi
fi

ALL=0
CHECK=0
HOST_ONLY=0
NO_PREBUILD=0
CONFIGURATION="${DEV_UP_CONFIGURATION:-debug}"
PATCHBAY_ONLY=0
RUN_ROBOT=${DEV_UP_RUN_ROBOT:-0}
for a in "$@"; do
  if [[ "$a" == "--help" || "$a" == "-h" ]]; then
    usage
    exit 0
  fi
  if [[ "$a" == "--all" ]]; then ALL=1; fi
  if [[ "$a" == "--check" ]]; then CHECK=1; fi
  if [[ "$a" == "--patchbay-only" ]]; then PATCHBAY_ONLY=1; fi
  if [[ "$a" == "--host-only" ]]; then HOST_ONLY=1; fi
  if [[ "$a" == "--no-prebuild" ]]; then NO_PREBUILD=1; fi
  if [[ "$a" == "--robot" ]]; then RUN_ROBOT=1; fi
done

# Default experience: start agent-host only unless explicitly asked otherwise
if [[ $ALL -eq 0 && $PATCHBAY_ONLY -eq 0 && $HOST_ONLY -eq 0 ]]; then
  HOST_ONLY=1
fi

# Populate optional OpenAI configuration from Keychain when available.
if [[ -z "${OPENAI_API_KEY:-}" ]]; then
  if command -v security >/dev/null 2>&1; then
    if security find-generic-password -s FountainAI -a OPENAI_API_KEY -w >/dev/null 2>&1; then
      OPENAI_API_KEY="$(security find-generic-password -s FountainAI -a OPENAI_API_KEY -w 2>/dev/null || true)"
      export OPENAI_API_KEY
    fi
  fi
fi

if [[ -n "${OPENAI_API_KEY:-}" && -z "${LLM_BACKEND:-}" ]]; then
  export LLM_BACKEND=openai
fi

# Spec sync check (PatchBay InstrumentKind) — fail fast in dev if drift
if [[ -x "$REPO_ROOT/Scripts/ci/check-patchbay-spec-sync.sh" ]]; then
  echo "[dev-up] Checking PatchBay spec sync (InstrumentKind)…"
  if ! bash "$REPO_ROOT/Scripts/ci/check-patchbay-spec-sync.sh" >/dev/null; then
    echo "[dev-up] ERROR: PatchBay spec drift detected. See Scripts/ci/check-patchbay-spec-sync.sh output." >&2
    bash "$REPO_ROOT/Scripts/ci/check-patchbay-spec-sync.sh" || true
    exit 2
  fi
fi

# Helpers
port_for() {
  case "$1" in
    agent-host) echo "${HOST_HEALTH_PORT:-8787}" ;;
    baseline-awareness) echo "${BASELINE_AWARENESS_PORT:-8001}" ;;
    bootstrap) echo "${BOOTSTRAP_PORT:-8002}" ;;
    planner) echo "${PLANNER_PORT:-8003}" ;;
    function-caller) echo "${FUNCTION_CALLER_PORT:-8004}" ;;
    persist) echo "${FOUNTAINSTORE_PORT:-8005}" ;;
    midi) echo "${MIDI_SERVICE_PORT:-7180}" ;;
    gateway) echo "${GATEWAY_PORT:-${PORT:-8010}}" ;;
    semantic-browser) echo "${SEMANTIC_BROWSER_PORT:-8007}" ;;
    tools-factory) echo "${TOOLS_FACTORY_PORT:-8011}" ;;
    tool-server) echo "${PORT:-8012}" ;;
    patchbay) echo "${PATCHBAY_PORT:-7090}" ;;
    patchbay-ui) echo 0 ;;
    *) echo 0 ;;
  esac
}

is_port_listening() {
  local port="$1"
  [[ "$port" -eq 0 ]] && return 1
  if command -v lsof >/dev/null 2>&1; then
    lsof -nP -iTCP:"$port" -sTCP:LISTEN >/dev/null 2>&1
    return $?
  fi
  return 1
}

http_200() {
  local url="$1"
  command -v curl >/dev/null 2>&1 || return 1
  curl -sf --max-time 2 "$url" >/dev/null 2>&1
}

wait_ready() {
  local name="$1"; shift
  local url="$1"; shift
  local timeout="${1:-30}"; shift || true
  local start=$(date +%s)
  while true; do
    if http_200 "$url"; then
      echo "[dev-up] $name ready at $url"
      return 0
    fi
    local now=$(date +%s)
    if (( now - start >= timeout )); then
      echo "[dev-up] WARN: $name not ready after ${timeout}s ($url)" >&2
      return 1
    fi
    sleep 0.5
  done
}

# JSON probe helpers (used for gateway metrics shape)
http_json_ok() {
  local url="$1"
  command -v curl >/dev/null 2>&1 || return 1
  local body
  body=$(curl -sf --max-time 3 -H 'Accept: application/json' "$url" 2>/dev/null) || return 1
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY' "$body" >/dev/null 2>&1 || exit 1
import sys, json
json.loads(sys.argv[1])
PY
  fi
}

wait_ready_json() {
  local name="$1"; shift
  local url="$1"; shift
  local timeout="${1:-30}"; shift || true
  local start=$(date +%s)
  while true; do
    if http_json_ok "$url"; then
      echo "[dev-up] $name ready (JSON) at $url"
      return 0
    fi
    local now=$(date +%s)
    if (( now - start >= timeout )); then
      echo "[dev-up] WARN: $name JSON not ready after ${timeout}s ($url)" >&2
      return 1
    fi
    sleep 0.5
  done
}

# Prefer prebuilt binaries by default; build once if missing.
USE_BIN="${DEV_UP_USE_BIN:-1}"
NEEDS_BUILD=0
DEFAULT_PKG_PATH="$REPO_ROOT/Packages/FountainApps"

bin_dir_for() {
  local pkg_path="$1"
  # Use SwiftPM configuration symlink for portability (debug/release)
  echo "$pkg_path/.build/$CONFIGURATION"
}

# Build a single product to avoid full-package failures slowing down boot.
build_product() {
  local pkg_path="$1"; shift
  local product="$1"; shift
  echo "[dev-up] Building product $product (configuration=$CONFIGURATION)…"
  swift build --package-path "$pkg_path" --configuration "$CONFIGURATION" --product "$product"
}

# Ensure a specific product exists in .build; if not, compile it only.
ensure_compiled() {
  local pkg_path="$1"; shift
  local product="$1"; shift
  local bin_dir
  bin_dir=$(bin_dir_for "$pkg_path")
  if [[ ! -x "$bin_dir/$product" ]]; then
    build_product "$pkg_path" "$product" || return 1
  fi
}

start_bg() {
  local name="$1"; shift
  local target="$1"; shift
  local pkg_rel_path="${1:-Packages/FountainApps}"; shift || true
  local pkg_path="$REPO_ROOT/$pkg_rel_path"
  local pid_file="$PID_DIR/$name.pid"
  local log_file="$LOG_DIR/$name.log"
  # Migrate any legacy pid files accidentally written to the logs directory by older scripts
  local legacy_pid1="$LOG_DIR/$name.pid"
  if [[ -f "$legacy_pid1" ]]; then mv -f "$legacy_pid1" "$pid_file" 2>/dev/null || true; fi
  # Also migrate pid files named after the product without the '-server' suffix (e.g., patchbay-service)
  local base_target="${target%-server}"
  local legacy_pid2="$LOG_DIR/$base_target.pid"
  if [[ -f "$legacy_pid2" ]]; then mv -f "$legacy_pid2" "$PID_DIR/$base_target.pid" 2>/dev/null || true; fi
  local port
  port=$(port_for "$name")
  if [[ -f "$pid_file" ]] && kill -0 "$(cat "$pid_file" 2>/dev/null)" 2>/dev/null; then
    echo "[dev-up] $name already running (pid $(cat "$pid_file"))"
    return 0
  fi
  if is_port_listening "$port"; then
    echo "[dev-up] $name port :$port already bound; skipping start"
    return 0
  fi
  : >"$log_file"
  echo "[dev-up] Starting $name → $log_file"
  if [[ "$USE_BIN" == "1" ]]; then
    local bin_dir
    bin_dir=$(bin_dir_for "$pkg_path")
    if [[ ! -x "$bin_dir/$target" ]]; then
      echo "[dev-up] Building $target (one-time, product-only)…"
      ensure_compiled "$pkg_path" "$target" || {
        echo "[dev-up] ERROR: failed to build $target" >&2
        return 1
      }
    fi
    if [[ "$name" == "patchbay-ui" ]]; then
      nohup env LAUNCHER_SIGNATURE="$SIG" APP_TITLE="Baseline‑PatchBay" \
        "$bin_dir/$target" >>"$log_file" 2>&1 &
    else
      nohup env LAUNCHER_SIGNATURE="$SIG" \
        "$bin_dir/$target" >>"$log_file" 2>&1 &
    fi
  else
    if [[ "$name" == "patchbay-ui" ]]; then
      nohup env LAUNCHER_SIGNATURE="$SIG" APP_TITLE="Baseline‑PatchBay" \
        swift run --package-path "$pkg_path" "$target" \
          >>"$log_file" 2>&1 &
    else
      nohup env LAUNCHER_SIGNATURE="$SIG" \
        swift run --package-path "$pkg_path" "$target" \
          >>"$log_file" 2>&1 &
    fi
  fi
  echo $! >"$pid_file"
  sleep 0.2
}

# Prebuild path: compile all standard server products, optionally extras, then exit
if [[ "${1:-}" == "prebuild" ]]; then
  shift || true
  # Parse flags again for --all
  for a in "$@"; do
    if [[ "$a" == "--all" ]]; then ALL=1; fi
    if [[ "$a" == "--patchbay-only" ]]; then PATCHBAY_ONLY=1; fi
  done
  echo "[dev-up] Prebuilding server binaries (configuration=$CONFIGURATION)…"
  echo "[dev-up] Seeding OpenAPI → facts…"
  bash "$REPO_ROOT/Scripts/facts/seed-agents.sh" || true
  if [[ "$PATCHBAY_ONLY" == "1" ]]; then
    # Fast path: only PatchBay service/UI + MIDI service
    build_product "$REPO_ROOT/Packages/FountainApps" midi-service-server || exit 1
    build_product "$REPO_ROOT/Packages/FountainApps" patchbay-service-server || exit 1
    build_product "$REPO_ROOT/Packages/FountainApps" patchbay-app || exit 1
  else
    # Core servers (FountainApps)
    core_targets=(agent-host baseline-awareness-server bootstrap-server planner-server function-caller-server persist-server midi-service-server gateway-server)
    for t in "${core_targets[@]}"; do
      build_product "$REPO_ROOT/Packages/FountainApps" "$t" || exit 1
    done
    # Optional extras
    if [[ "$ALL" == "1" ]]; then
      build_product "$REPO_ROOT/Packages/FountainApps" tools-factory-server || exit 1
      build_product "$REPO_ROOT/Packages/FountainApps" tool-server || exit 1
      build_product "$REPO_ROOT/Packages/FountainApps" publishing-frontend || exit 1
      build_product "$REPO_ROOT/Packages/FountainApps-SemanticBrowser" semantic-browser-server || exit 1
    fi
  fi
  echo "[dev-up] Prebuild complete. Binaries under Packages/*/.build/$CONFIGURATION"
  exit 0
fi

if [[ "${DEV_UP_NO_START_LOCAL_AGENT:-0}" != "1" ]]; then
  echo "[dev-up] Ensuring LocalAgent (see .fountain/logs/launcher.log)"
  "$REPO_ROOT/Scripts/launcher" start || true
fi

if [[ "$HOST_ONLY" == "1" ]]; then
  # Fastest profile: start agent-host only
  echo "[dev-up] Seeding OpenAPI → facts…"
  bash "$REPO_ROOT/Scripts/facts/seed-agents.sh" || true
  if [[ "$NO_PREBUILD" != "1" ]]; then
    build_product "$REPO_ROOT/Packages/FountainApps" agent-host || true
  fi
  start_bg agent-host agent-host Packages/FountainApps
  if [[ "$CHECK" == "1" ]]; then
    wait_ready agent-host "http://127.0.0.1:$(port_for agent-host)/ready" 10 || true
  fi
  echo "[dev-up] agent-host started (host-only mode)."
  exit 0
elif [[ "$PATCHBAY_ONLY" == "1" ]]; then
  # Fast profile: start MIDI service + PatchBay service/UI only
  start_bg midi "midi-service-server" Packages/FountainApps
  start_bg patchbay patchbay-service-server Packages/FountainApps
  if [[ "$CHECK" == "1" ]]; then
    wait_ready_json midi "http://127.0.0.1:$(port_for midi)/health" 10 || true
    wait_ready patchbay "http://127.0.0.1:$(port_for patchbay)/health" 20 || true
  fi
  # In patchbay-only mode, skip full control-plane boot and heavy UI test builds.
  # Launch the Baseline PatchBay UI once services are up, then exit.
  echo "[dev-up] Building Baseline PatchBay app (patchbay-only)…"
  swift build --package-path "$REPO_ROOT/Packages/FountainApps" --configuration "$CONFIGURATION" --product baseline-patchbay || {
    echo "[dev-up] WARN: failed to build baseline-patchbay product" >&2
  }
  if [[ "${DEV_UP_NO_PATCHBAY_UI:-0}" != "1" ]]; then
    start_bg patchbay-ui baseline-patchbay Packages/FountainApps
  fi
  echo "[dev-up] PatchBay workbench started (patchbay-only mode)."
  exit 0
else
    # Core services (ordered: deps first, gateway last)
  start_bg agent-host agent-host Packages/FountainApps
    start_bg baseline-awareness baseline-awareness-server Packages/FountainApps
    start_bg bootstrap bootstrap-server Packages/FountainApps
    start_bg planner planner-server Packages/FountainApps
  start_bg function-caller function-caller-server Packages/FountainApps
  start_bg persist persist-server Packages/FountainApps
  start_bg midi "midi-service-server" Packages/FountainApps
  start_bg gateway gateway-server Packages/FountainApps
  start_bg patchbay patchbay-service-server Packages/FountainApps
  if [[ "$CHECK" == "1" ]]; then
    wait_ready agent-host "http://127.0.0.1:$(port_for agent-host)/ready" 10 || true
    wait_ready_json midi "http://127.0.0.1:$(port_for midi)/health" 10 || true
    wait_ready patchbay "http://127.0.0.1:$(port_for patchbay)/health" 20 || true
  fi
fi

# Build Baseline PatchBay app and its GUI tests (compile-time gate for UI focus invariants)
echo "[dev-up] Building Baseline PatchBay app (compile only)…"
swift build --package-path "$REPO_ROOT/Packages/FountainApps" --configuration "$CONFIGURATION" --product baseline-patchbay
echo "[dev-up] Building PatchBayAppUITests (compile only)…"
swift build --package-path "$REPO_ROOT/Packages/FountainApps" --configuration "$CONFIGURATION" --target PatchBayAppUITests

# Launch PatchBay UI as the default face (unless disabled)
if [[ "${DEV_UP_NO_PATCHBAY_UI:-0}" != "1" ]]; then
  # Launch Baseline PatchBay UI (baseline-patchbay product)
  start_bg patchbay-ui baseline-patchbay Packages/FountainApps
fi
if [[ "$CHECK" == "1" ]]; then
  echo "[dev-up] UI smoke (PatchBay goldens)…"
  bash "$REPO_ROOT/Scripts/ci/ui-smoke.sh" || {
    echo "[dev-up] UI smoke failed (see .fountain/artifacts)." >&2
    exit 3
  }
fi
if [[ "$RUN_ROBOT" == "1" ]]; then
  echo "[dev-up] Running robot tests subset…"
  bash "$REPO_ROOT/Scripts/ci/robot-run.sh" || true
fi
