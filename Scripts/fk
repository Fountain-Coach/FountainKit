#!/usr/bin/env bash
set -euo pipefail

ROOT=$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)
export ROOT

LAUNCHER_SIGNATURE=${LAUNCHER_SIGNATURE:-B86D7CEE-24C4-4C4C-A107-8D0542D1965B}

die(){ echo "error: $*" >&2; exit 1; }
req(){ command -v "$1" >/dev/null 2>&1 || die "$1 not found; please install"; }

# Read simple key: value from Configuration/readability.yaml (top-level only)
conf_val(){
  local key="$1"; local file="$ROOT/Configuration/readability.yaml"
  [[ -f "$file" ]] || return 0
  awk -F: -v k="^"$key":" 'BEGIN{ORS=""} $0 ~ k { $1=""; sub(/^:[ \t]*/,"",$0); sub(/[ \t\r\n]+$/,"",$0); print $0; exit }' "$file"
}

# Locate a Chromium/Chrome binary for headless PDF export
find_chrome(){
  for bin in google-chrome-stable google-chrome chromium chromium-browser \
             "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" \
             "/Applications/Chromium.app/Contents/MacOS/Chromium"; do
    if command -v "$bin" >/dev/null 2>&1; then echo "$bin"; return 0; fi
    [[ -x "$bin" ]] && { echo "$bin"; return 0; }
  done
  return 1
}

doctor(){
  echo "[fk] Doctor: checking tools…"
  for bin in swift docker jq curl; do
    if command -v "$bin" >/dev/null 2>&1; then echo "✓ $bin"; else echo "✗ $bin (missing)"; fi
  done
}

init(){
  echo "[fk] Initialize tool-server config (.env)…"
  "$ROOT/Scripts/toolserver" init
}

build(){
  echo "[fk] swift build (workspace)…"
  swift build
}

up(){
  echo "[fk] Bringing up core services…"
  LAUNCHER_SIGNATURE="$LAUNCHER_SIGNATURE" DEV_UP_USE_BIN=1 DEV_UP_CHECKS=1 bash "$ROOT/Scripts/dev-up"
}

down(){
  echo "[fk] Shutting down core services…"
  bash "$ROOT/Scripts/dev-down" --force
}

status(){
  echo "[fk] Status (core)…"
  bash "$ROOT/Scripts/dev-status" || true
  echo "[fk] Status (tool-server)…"
  "$ROOT/Scripts/toolserver" status || true
}

api(){
  local url=${1:-}; shift || true
  local method=${METHOD:-GET}
  local data=${DATA:-}
  local file=${FILE:-}
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -X|--method) method=$2; shift 2;;
      -d|--data) data=$2; shift 2;;
      -f|--file) file=$2; shift 2;;
      *) url=${url:-$1}; shift;;
    esac
  done
  [[ -n "$url" ]] || die "usage: fk api <url> [-X METHOD] [-d JSON] [-f FILE]"
  if [[ -n "$file" ]]; then
    curl -sf -X "$method" -H 'Content-Type: application/json' --data-binary @"$file" "$url" | jq .
  elif [[ -n "$data" ]]; then
    curl -sf -X "$method" -H 'Content-Type: application/json' -d "$data" "$url" | jq .
  else
    curl -sf -X "$method" "$url" | jq .
  fi
}

help(){ cat <<USAGE
FountainKit helper CLI (humans + LLMs)

Usage: fk <command>

Commands:
  doctor          Check required tools (swift, docker, jq, curl)
  init            Generate/refresh Tool Server .env
  build           Build entire workspace (swift build)
  up              Start core services (dev-up)
  down            Stop core services (dev-down)
  status          Show status of core services and tool-server
  logs [what]     Stream logs: 'compose' or 'tool-server'
  open <target>   Open common endpoints in browser
  open schema <target>  Open OpenAPI document (/openapi.yaml) for a target
  open list       Print all targets, ports, and URLs
  api <url>       Generic HTTP call with JSON helpers
  export persist  Export pages/segments (and more) to fixtures
  verify          Compare an edition against canonical web sources (Semantic Browser)
  verify corpus   Verify all plays in the Four Stars fountain against canonical sources
  read scene      Render a human-readable scene script (Speech Atlas)
  read act        Render a whole act by stitching scenes
  read play       Render the whole play by stitching acts & scenes
  scripts list    List scripts from the scripts corpus
  scripts show    Show details for a script (header/usage)
  scripts drift   Show latest scripts drift report
  engraving tui   Launch Engraving TUI (SwiftCurses)
  engraving bootstrap  Create corpus and seed a starter plan
  engraving ingest-code  Ingest .swift files as pages/segments

Shortcuts:
  toolserver ...  Proxy to Scripts/toolserver
  ts-api ...      Proxy to Scripts/toolserver-api
  export ...      Proxy to Scripts/export-persist
  read ...        Speech Atlas helpers (scene/act/play script)

Examples:
  fk up
  fk status
  fk api http://127.0.0.1:8012/_status
  fk toolserver run exiftool -- -ver
  fk ts-api imagemagick -- magick -version
USAGE
}

case "${1:-help}" in
  doctor) shift; doctor "$@" ;;
  init|configure) shift; init "$@" ;;
  build) shift; build "$@" ;;
  up) shift; up "$@" ;;
  down) shift; down "$@" ;;
  status) shift; status "$@" ;;
  logs)
    shift
    case "${1:-compose}" in
      compose) shift; "$ROOT/Scripts/toolserver" logs compose "$@" ;;
      tool-server) shift; "$ROOT/Scripts/toolserver" logs tool-server "$@" ;;
      *) echo "usage: fk logs <compose|tool-server>" ;;
    esac ;;
  open)
    shift
    if [[ "${1:-}" == "list" ]]; then
      shift || true
      host=${HOST:-127.0.0.1}
      json=0
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --json|-j) json=1; shift;;
          --host) host=$2; shift 2;;
          *) break;;
        esac
      done
      if (( json )); then
        cat <<JSON
[
  {"target":"gateway","port":8010,"metrics":"http://$host:8010/metrics","schema":"http://$host:8010/openapi.yaml"},
  {"target":"baseline-awareness","port":8001,"metrics":"http://$host:8001/metrics","schema":"http://$host:8001/openapi.yaml"},
  {"target":"bootstrap","port":8002,"metrics":"http://$host:8002/metrics","schema":"http://$host:8002/openapi.yaml"},
  {"target":"planner","port":8003,"metrics":"http://$host:8003/metrics","schema":"http://$host:8003/openapi.yaml"},
  {"target":"function-caller","port":8004,"metrics":"http://$host:8004/metrics","schema":"http://$host:8004/openapi.yaml"},
  {"target":"persist","port":8005,"metrics":"http://$host:8005/metrics","schema":"http://$host:8005/openapi.yaml"},
  {"target":"midi-service","port":7180,"status":"http://$host:7180/health","schema":"http://$host:7180/openapi.yaml"},
  {"target":"semantic-browser","port":8007,"metrics":"http://$host:8007/metrics","schema":"http://$host:8007/openapi.yaml"},
  {"target":"tools-factory","port":8011,"metrics":"http://$host:8011/metrics","schema":"http://$host:8011/openapi.yaml"},
  {"target":"tool-server","port":8012,"status":"http://$host:8012/_status","schema":"http://$host:8012/openapi.yaml"}
]
JSON
      else
        cat <<LIST
Target            Port   Metrics/Status URL                         Schema URL
gateway           8010   http://$host:8010/metrics                   http://$host:8010/openapi.yaml
baseline-awareness 8001  http://$host:8001/metrics                   http://$host:8001/openapi.yaml
bootstrap         8002   http://$host:8002/metrics                   http://$host:8002/openapi.yaml
planner           8003   http://$host:8003/metrics                   http://$host:8003/openapi.yaml
function-caller   8004   http://$host:8004/metrics                   http://$host:8004/openapi.yaml
persist           8005   http://$host:8005/metrics                   http://$host:8005/openapi.yaml
midi-service      7180   http://$host:7180/health                    http://$host:7180/openapi.yaml
semantic-browser  8007   http://$host:8007/metrics                   http://$host:8007/openapi.yaml
tools-factory     8011   http://$host:8011/metrics                   http://$host:8011/openapi.yaml
tool-server       8012   http://$host:8012/_status                  http://$host:8012/openapi.yaml
LIST
      fi
      exit 0
    fi
    if [[ "${1:-}" == "schema" ]]; then
      shift
      tgt=${1:-}; shift || true
      [[ -n "$tgt" ]] || { echo "usage: fk open schema <gateway|planner|function-caller|persist|bootstrap|awareness|tools-factory|tool-server|semantic-browser|midi-service>"; exit 1; }
      case "$tgt" in
        gateway) url=http://127.0.0.1:8010/openapi.yaml ;;
        planner) url=http://127.0.0.1:8003/openapi.yaml ;;
        function-caller) url=http://127.0.0.1:8004/openapi.yaml ;;
        persist) url=http://127.0.0.1:8005/openapi.yaml ;;
        bootstrap) url=http://127.0.0.1:8002/openapi.yaml ;;
        awareness) url=http://127.0.0.1:8001/openapi.yaml ;;
        tools-factory) url=http://127.0.0.1:8011/openapi.yaml ;;
        tool-server) url=http://127.0.0.1:8012/openapi.yaml ;;
        semantic-browser) url=http://127.0.0.1:8007/openapi.yaml ;;
        midi-service) url=http://127.0.0.1:7180/openapi.yaml ;;
        *) echo "unknown target: $tgt"; exit 1;;
      esac
    else
      tgt=${1:-}; shift || true
      [[ -n "$tgt" ]] || { echo "usage: fk open <gateway|planner|function-caller|persist|bootstrap|awareness|tools-factory|tool-server|semantic-browser|midi-service>"; exit 1; }
      case "$tgt" in
        gateway) url=http://127.0.0.1:8010/metrics ;;
        planner) url=http://127.0.0.1:8003/metrics ;;
        function-caller) url=http://127.0.0.1:8004/metrics ;;
        persist) url=http://127.0.0.1:8005/metrics ;;
        bootstrap) url=http://127.0.0.1:8002/metrics ;;
        awareness) url=http://127.0.0.1:8001/metrics ;;
        tools-factory) url=http://127.0.0.1:8011/metrics ;;
        tool-server) url=http://127.0.0.1:8012/_status ;;
        semantic-browser) url=http://127.0.0.1:8007/metrics ;;
        midi-service) url=http://127.0.0.1:7180/health ;;
        *) echo "unknown target: $tgt"; exit 1;;
      esac
    fi
    if command -v open >/dev/null 2>&1; then open "$url"; else xdg-open "$url"; fi ;;
  api) shift; api "$@" ;;
  toolserver) shift; "$ROOT/Scripts/toolserver" "$@" ;;
  ts-api) shift; "$ROOT/Scripts/toolserver-api" "$@" ;;
  export)
    shift
    sub=${1:-}
    case "$sub" in
      persist)
        shift
        "$ROOT/Scripts/export-persist" "$@"
        ;;
      *) echo "usage: fk export persist [--corpus <id>] [--out <dir>] [--url <persist-url>] [--api-key <key>]" ;;
    esac ;;
  verify)
    shift
    if [[ "${1:-}" == "corpus" ]]; then
      shift
      __sb_url="${SEMANTIC_BROWSER_URL:-}"
      __sb_port="${SEMANTIC_BROWSER_PORT:-8007}"
      if [[ -z "$__sb_url" ]]; then __sb_url="http://127.0.0.1:$__sb_port"; fi
      "$ROOT/Scripts/verify-shakespeare-corpus" --sb-url "$__sb_url" "$@"
      exit 0
    fi
    SB_BASE="${SEMANTIC_BROWSER_URL:-http://127.0.0.1:${SEMANTIC_BROWSER_PORT:-8007}}"
    EDITION_URL=""; EDITION_FILE=""; EDITION_TEXT=""; EDITION_TITLE=""; SHINGLE=3; MAX_EX=20; MIN_LINE=12; JSON=0
    declare -a CANONICAL
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --edition-url) EDITION_URL=${2:-}; shift 2;;
        --edition-file) EDITION_FILE=${2:-}; shift 2;;
        --edition-text) EDITION_TEXT=${2:-}; shift 2;;
        --title) EDITION_TITLE=${2:-}; shift 2;;
        --canonical-url) CANONICAL+=("${2:-}"); shift 2;;
        --canonical-list) while IFS= read -r line; do [[ -n "$line" ]] && CANONICAL+=("$line"); done < "${2:-}"; shift 2;;
        --url) SB_BASE=${2:-}; shift 2;;
        --shingle|--shingle-size) SHINGLE=${2:-}; shift 2;;
        --max-examples) MAX_EX=${2:-}; shift 2;;
        --min-line-len) MIN_LINE=${2:-}; shift 2;;
        --json) JSON=1; shift 1;;
        *) break;;
      esac
    done
    [[ -n "$EDITION_URL" || -n "$EDITION_FILE" || -n "$EDITION_TEXT" ]] || { echo "usage: fk verify [--edition-url URL|--edition-file FILE|--edition-text TEXT] [--title TITLE] --canonical-url URL [--canonical-url URL ...] [--canonical-list FILE] [--url SB_BASE] [--shingle N] [--max-examples N] [--min-line-len N] [--json]"; exit 2; }
    [[ ${#CANONICAL[@]} -gt 0 ]] || { echo "error: at least one --canonical-url or --canonical-list required"; exit 2; }
    # Build edition object
    ed_fields=()
    [[ -n "$EDITION_TITLE" ]] && ed_fields+=("\"title\":\"$EDITION_TITLE\"")
    if [[ -n "$EDITION_URL" ]]; then
      ed_fields+=("\"url\":\"$EDITION_URL\"")
    elif [[ -n "$EDITION_FILE" ]]; then
      ED_TXT=$(cat "$EDITION_FILE" | python3 - <<'PY'
import sys, json
data=sys.stdin.read()
print(json.dumps(data))
PY
)
      ed_fields+=("\"text\":$ED_TXT")
    else
      # Raw text provided
      ED_TXT=$(python3 - <<PY
import json, sys
print(json.dumps(sys.argv[1]))
PY
"$EDITION_TEXT")
      ed_fields+=("\"text\":$ED_TXT")
    fi
    edition_json="{${ed_fields[*]}}"
    # Canonical array: support lines of either URL or NAME|URL
    canon_items=()
    for item in "${CANONICAL[@]}"; do
      name=""; url="$item"
      if [[ "$item" == *"|"* ]]; then name="${item%%|*}"; url="${item#*|}"; fi
      if [[ -n "$name" ]]; then
        canon_items+=("{\"name\":\"$name\",\"url\":\"$url\"}")
      else
        canon_items+=("{\"url\":\"$url\"}")
      fi
    done
    canonical_json="[${canon_items[*]}]"
    options_json="{\"shingleSize\":$SHINGLE,\"maxExamples\":$MAX_EX,\"minLineLen\":$MIN_LINE}"
    body="{\"edition\":$edition_json,\"canonical\":$canonical_json,\"options\":$options_json}"
    url="$SB_BASE/v1/verify"
    resp=$(curl -sf -X POST "$url" -H 'Content-Type: application/json' -d "$body") || { echo "error: request failed" >&2; exit 1; }
    if (( JSON )); then printf "%s\n" "$resp" | jq .; exit 0; fi
    # Summary line
    best=$(printf "%s\n" "$resp" | jq -r '.summary.bestSource // ""')
    sj=$(printf "%s\n" "$resp" | jq -r '.summary.shingleJaccardBest // 0')
    tj=$(printf "%s\n" "$resp" | jq -r '.summary.tokenJaccardBest // 0')
    lc=$(printf "%s\n" "$resp" | jq -r '.summary.lineCoverageBest // 0')
    printf "Best source: %s (shingleJ=%.3f, tokenJ=%.3f, lineCov=%.3f)\n" "$best" "$sj" "$tj" "$lc"
    # Table header
    printf "\n%-32s  %-6s  %-8s  %-8s\n" "Source" "k" "Jacc(T)" "Jacc(k)"
    printf "%-32s  %-6s  %-8s  %-8s\n" "--------------------------------" "------" "--------" "--------"
    printf "%s\n" "$resp" | jq -r --arg k "$SHINGLE" '
      .results[] | [(.source.name // .source.url), (.metrics.editionTokens|tostring+"/"+(.metrics.canonicalTokens|tostring)), (.metrics.tokenJaccard|tostring), (.metrics.shingleJaccard|tostring)] | @tsv
    ' | while IFS=$'\t' read -r name tok j1 j2; do
      printf "%-32s  %-6s  %-8.3f  %-8.3f\n" "${name:0:32}" "$tok" "$j1" "$j2"
    done
    # Examples (first source)
    first_missing=$(printf "%s\n" "$resp" | jq -r '.results[0].examples.missingFromEdition[]? | .[0:120]') || true
    if [[ -n "$first_missing" ]]; then
      printf "\nMissing (from first source):\n"
      printf " - %s\n" $first_missing
    fi
    ;;
  scripts)
    shift
    sub=${1:-}; shift || true
    case "$sub" in
      list)
        "$ROOT/Scripts/print-scripts" list "$@" ;;
      show)
        "$ROOT/Scripts/print-scripts" show "$@" ;;
      drift)
        "$ROOT/Scripts/print-scripts-drift" "$@" ;;
      *) echo "usage: fk scripts <list|show> [args]" ;;
    esac ;;
  engraving)
    shift
    sub=${1:-}; shift || true
    case "$sub" in
      tui)
        ENGRAVING_CORPUS_ID="${ENGRAVING_CORPUS_ID:-engraving-lab}" \
          swift run --package-path "$ROOT/Packages/FountainApps" engraving-tui ;;
      bootstrap)
        CORPUS="${1:-engraving-lab}"; shift || true
        echo "[engraving] bootstrap corpus $CORPUS" >&2
        curl -sf -X POST "http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}/corpora" -H 'Content-Type: application/json' -d '{"corpusId":"'"$CORPUS"'"}' >/dev/null || true
        PLAN_ID="plan:starter"
        curl -sf -X POST "http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}/corpora/$CORPUS/pages" -H 'Content-Type: application/json' -d '{"corpusId":"'"$CORPUS"'","pageId":"'"$PLAN_ID"'","url":"store://plan/starter","host":"store","title":"Engraving Plan"}' >/dev/null || true
        curl -sf -X POST "http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}/corpora/$CORPUS/segments" -H 'Content-Type: application/json' -d '{"corpusId":"'"$CORPUS"'","segmentId":"'"$PLAN_ID"':notes","pageId":"'"$PLAN_ID"'","kind":"notes","text":"- [ ] Set up corpus\n- [ ] Ingest code\n- [ ] Run rules\n- [ ] Baseline and drift"}' >/dev/null || true
        echo "[engraving] bootstrap complete" ;;
      ingest-code)
        CORPUS="${1:-engraving-lab}"; shift || true
        ROOTDIR="${1:-$ROOT}"; shift || true
        echo "[engraving] ingest code from $ROOTDIR into $CORPUS" >&2
        while IFS= read -r -d '' file; do
          rel=${file#"$ROOTDIR/"}
          sha=$(shasum -a 256 "$file" | awk '{print $1}'); id="file:${rel//@/at}@${sha:0:12}"
          host=repo; url="file://$file"; title="$rel"
          curl -sf -X POST "http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}/corpora/$CORPUS/pages" -H 'Content-Type: application/json' -d '{"corpusId":"'"$CORPUS"'","pageId":"'"$id"'","url":"'"$url"'","host":"'"$host"'","title":"'"$title"'"}' >/dev/null || true
          text=$(python3 - <<PY
import sys, json
print(json.dumps(open(sys.argv[1],'r',encoding='utf-8',errors='ignore').read()))
PY
"$file")
          curl -sf -X POST "http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}/corpora/$CORPUS/segments" -H 'Content-Type: application/json' -d '{"corpusId":"'"$CORPUS"'","segmentId":"'"$id"':code","pageId":"'"$id"'","kind":"code","text":'"$text"'}' >/dev/null || true
        done < <(find "$ROOTDIR" -type f -name '*.swift' -print0)
        echo "[engraving] ingest complete" ;;
      *) echo "usage: fk engraving <tui|bootstrap|ingest-code> [args]" ;;
    esac ;;
  read)
    shift
    sub=${1:-}; shift || true
    case "$sub" in
      scene)
        ACT=""; SCENE=""; FORMAT="markdown"; LAYOUT="readable"; CORPUS="${CORPUS_ID:-the-four-stars}"; BASE="${PERSIST_URL:-http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}}"; PAGER_ON=1; OUT_FILE=""; OPEN_HTML=0; OPEN_NATIVE=0
        while [[ $# -gt 0 ]]; do
          case "$1" in
            --act) ACT=${2:-}; shift 2;;
            --scene) SCENE=${2:-}; shift 2;;
            --format) FORMAT=${2:-}; shift 2;;
            --layout) LAYOUT=${2:-}; shift 2;;
            --corpus) CORPUS=${2:-}; shift 2;;
            --url) BASE=${2:-}; shift 2;;
            --out) OUT_FILE=${2:-}; shift 2;;
            --open) OPEN_NATIVE=1; shift 1;;
            --open-html) OPEN_HTML=1; shift 1;;
            --no-pager) PAGER_ON=0; shift 1;;
            *) break;;
          esac
        done
        [[ -n "$ACT" && -n "$SCENE" ]] || { echo "usage: fk read scene --act <I> --scene <II> [--format markdown|json] [--layout readable|screenplay] [--corpus id] [--url base] [--out file] [--open|--open-html] [--no-pager]"; exit 2; }
        req=$(cat <<JSON
{"act":"$ACT","scene":"$SCENE","format":"$FORMAT","layout":"$LAYOUT","group_consecutive":true}
JSON
)
        url="$BASE/arcs/$CORPUS/speeches/script"
        if [[ "$FORMAT" == "json" ]]; then
          out=$(curl -sf -X POST "$url" -H 'Content-Type: application/json' -d "$req" | jq .)
          if [[ -n "$OUT_FILE" ]]; then printf "%s\n" "$out" > "$OUT_FILE"; fi
          printf "%s\n" "$out"
        else
          body=$(curl -sf -X POST "$url" -H 'Content-Type: application/json' -d "$req" | jq -r '.result.markdown')
          if [[ -n "$OUT_FILE" ]]; then printf "%s\n" "$body" > "$OUT_FILE"; fi
          if (( OPEN_HTML )); then
            html_file=${OUT_FILE:-"/tmp/scene-$ACT-$SCENE.html"}
            css_readable='body{margin:2rem auto;max-width:800px;background:#fff;color:#222;font:16px/1.6 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;} h1,h2,strong{color:#111} pre{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;background:#fafafa;padding:1rem;border-radius:.5rem;border:1px solid #eee}'
            css_screenplay='body{margin:2rem auto;max-width:860px;background:#fff;color:#111;font:16px/1.6 Courier New,Courier,monospace} pre{white-space:pre-wrap;font-family:inherit} h1,h2,strong{letter-spacing:.5px}'
            css="$css_readable"; [[ "$LAYOUT" == "screenplay" ]] && css="$css_screenplay"
            { printf "<html><head><meta charset=\"utf-8\"><title>Act %s Scene %s</title><style>%s</style></head><body><pre>" "$ACT" "$SCENE" "$css"; \
              printf "%s" "$body" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'; \
              printf "</pre></body></html>"; } > "$html_file"
            if command -v open >/dev/null 2>&1; then open "$html_file"; fi
          elif (( OPEN_NATIVE )); then
            file=${OUT_FILE:-"/tmp/scene-$ACT-$SCENE.md"}
            printf "%s\n" "$body" > "$file"
            if command -v open >/dev/null 2>&1; then open "$file"; fi
          else
            if (( PAGER_ON )) && command -v less >/dev/null 2>&1; then
              printf "%s\n" "$body" | less -R
            else
              printf "%s\n" "$body"
            fi
          fi
        fi
        ;;
      act)
        ACT=""; LAYOUT="readable"; CORPUS="${CORPUS_ID:-the-four-stars}"; BASE="${PERSIST_URL:-http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}}"; OUT_FILE=""; OPEN_HTML=0; OPEN_NATIVE=0; OPEN_PDF=0
        while [[ $# -gt 0 ]]; do
          case "$1" in
            --act) ACT=${2:-}; shift 2;;
            --layout) LAYOUT=${2:-}; shift 2;;
            --corpus) CORPUS=${2:-}; shift 2;;
            --url) BASE=${2:-}; shift 2;;
            --out) OUT_FILE=${2:-}; shift 2;;
            --open) OPEN_NATIVE=1; shift 1;;
            --open-html) OPEN_HTML=1; shift 1;;
            --pdf) OPEN_PDF=1; shift 1;;
            *) break;;
          esac
        done
        [[ -n "$ACT" ]] || { echo "usage: fk read act --act <I> [--corpus id] [--url base] [--out file] [--open|--open-html]"; exit 2; }
        scenes=$(curl -sf -X POST "$BASE/arcs/$CORPUS/speeches/list" -H 'Content-Type: application/json' -d "{\"act\":\"$ACT\",\"limit\":500,\"offset\":0}" | jq -r '[.result.items[].scene] | unique | .[]')
        doc="# Act $ACT\n"
        for SCENE in $scenes; do
          req=$(cat <<JSON
{"act":"$ACT","scene":"$SCENE","format":"markdown","layout":"$LAYOUT","group_consecutive":true}
JSON
)
          md=$(curl -sf -X POST "$BASE/arcs/$CORPUS/speeches/script" -H 'Content-Type: application/json' -d "$req" | jq -r '.result.markdown')
          md=$(printf "%s" "$md" | sed -e 's/^# /## /')
          doc+=$'\n'"$md"$'\n'
        done
        if [[ -n "$OUT_FILE" ]]; then printf "%s\n" "$doc" > "$OUT_FILE"; fi
        if (( OPEN_HTML )); then
          html_file=${OUT_FILE:-"/tmp/act-$ACT.html"}
          { printf "<html><head><meta charset=\"utf-8\"><title>Act %s</title></head><body><pre style=\"white-space:pre-wrap;font-family:ui-monospace,monospace\">" "$ACT"; \
            printf "%s" "$doc" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'; \
            printf "</pre></body></html>"; } > "$html_file"
          if command -v open >/dev/null 2>&1; then open "$html_file"; fi
        elif (( OPEN_NATIVE )); then
          file=${OUT_FILE:-"/tmp/act-$ACT.md"}
          printf "%s\n" "$doc" > "$file"
          if command -v open >/dev/null 2>&1; then open "$file"; fi
        else
          printf "%s\n" "$doc"
        fi
        ;;
      act)
        ACT=""; CORPUS="${CORPUS_ID:-the-four-stars}"; BASE="${PERSIST_URL:-http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}}"; OUT_FILE=""; OPEN_HTML=0; OPEN_NATIVE=0
        while [[ $# -gt 0 ]]; do
          case "$1" in
            --act) ACT=${2:-}; shift 2;;
            --corpus) CORPUS=${2:-}; shift 2;;
            --url) BASE=${2:-}; shift 2;;
            --out) OUT_FILE=${2:-}; shift 2;;
            --open) OPEN_NATIVE=1; shift 1;;
            --open-html) OPEN_HTML=1; shift 1;;
            *) break;;
          esac
        done
        [[ -n "$ACT" ]] || { echo "usage: fk read act --act <I> [--corpus id] [--url base] [--out file] [--open|--open-html]"; exit 2; }
        scenes=$(curl -sf -X POST "$BASE/arcs/$CORPUS/speeches/list" -H 'Content-Type: application/json' -d "{\"act\":\"$ACT\",\"limit\":2000,\"offset\":0}" | jq -r '[.result.items[].scene] | unique | .[]')
        doc="# Act $ACT\n"
        for SCENE in $scenes; do
          req=$(cat <<JSON
{"act":"$ACT","scene":"$SCENE","format":"markdown","group_consecutive":true}
JSON
)
          md=$(curl -sf -X POST "$BASE/arcs/$CORPUS/speeches/script" -H 'Content-Type: application/json' -d "$req" | jq -r '.result.markdown')
          md=$(printf "%s" "$md" | sed -e 's/^# /## /')
          doc+=$'\n'"$md"$'\n'
        done
        if [[ -n "$OUT_FILE" ]]; then printf "%s\n" "$doc" > "$OUT_FILE"; fi
        if (( OPEN_HTML || OPEN_PDF )); then
          html_file=${OUT_FILE:-"/tmp/act-$ACT.html"}
          css_readable='body{margin:2rem auto;max-width:800px;background:#fff;color:#222;font:16px/1.6 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;} h1,h2,strong{color:#111} .speaker{margin-top:1rem;font-weight:700} p{margin:.2rem 0}'
          css_screenplay='body{margin:2rem auto;max-width:860px;background:#fff;color:#111;font:16px/1.6 Courier New,Courier,monospace} h1{letter-spacing:.5px} .speaker{margin-top:1rem;font-weight:700;letter-spacing:.5px} .line{margin:.1rem 0 0 2rem}'
          css="$css_readable"; [[ "$LAYOUT" == "screenplay" ]] && css="$css_screenplay"
          { printf "<html><head><meta charset=\"utf-8\"><title>Act %s</title><style>%s</style></head><body><pre>" "$ACT" "$css"; \
            printf "%s" "$doc" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'; \
            printf "</pre></body></html>"; } > "$html_file"
          if (( OPEN_PDF )) && command -v wkhtmltopdf >/dev/null 2>&1; then
            pdf_file=${OUT_FILE:-"/tmp/act-$ACT"}; pdf_file=${pdf_file%.html}.pdf
            wkhtmltopdf "$html_file" "$pdf_file" >/dev/null 2>&1 || true
            if command -v open >/dev/null 2>&1; then open "$pdf_file"; fi
          else
            if command -v open >/dev/null 2>&1; then open "$html_file"; fi
          fi
        elif (( OPEN_NATIVE )); then
          file=${OUT_FILE:-"/tmp/act-$ACT.md"}
          printf "%s\n" "$doc" > "$file"
          if command -v open >/dev/null 2>&1; then open "$file"; fi
        else
          printf "%s\n" "$doc"
        fi
        ;;
      play)
        CORPUS="${CORPUS_ID:-the-four-stars}"; BASE="${PERSIST_URL:-http://127.0.0.1:${FOUNTAINSTORE_PORT:-8005}}"; OUT_FILE=""; OPEN_HTML=0; OPEN_NATIVE=0; OPEN_PDF=0; TITLE="Play"; LAYOUT="readable"
        while [[ $# -gt 0 ]]; do
          case "$1" in
            --corpus) CORPUS=${2:-}; shift 2;;
            --url) BASE=${2:-}; shift 2;;
            --out) OUT_FILE=${2:-}; shift 2;;
            --title) TITLE=${2:-}; shift 2;;
            --layout) LAYOUT=${2:-}; shift 2;;
            --open) OPEN_NATIVE=1; shift 1;;
            --open-html) OPEN_HTML=1; shift 1;;
            --pdf) OPEN_PDF=1; shift 1;;
            *) break;;
          esac
        done
        # Gather acts present (unique) and sort I,V via mapping
        acts=$(curl -sf -X POST "$BASE/arcs/$CORPUS/speeches/list" -H 'Content-Type: application/json' -d '{"limit":5000,"offset":0}' | jq -r '[.result.items[].act] | unique | .[]')
        # Simple roman order map
        order() { case "$1" in I) echo 1;; II) echo 2;; III) echo 3;; IV) echo 4;; V) echo 5;; VI) echo 6;; VII) echo 7;; VIII) echo 8;; IX) echo 9;; X) echo 10;; *) echo 999;; esac; }
        sorted_acts=$(for a in $acts; do printf "%02d %s\n" "$(order "$a")" "$a"; done | sort -n | awk '{print $2}')
        doc="# $TITLE\n"
        for ACT in $sorted_acts; do
          part=$(bash "$0" read act --act "$ACT" --layout "$LAYOUT" --corpus "$CORPUS" --url "$BASE" --no-pager)
          doc+=$'\n'"$part"$'\n'
        done
        if [[ -n "$OUT_FILE" ]]; then printf "%s\n" "$doc" > "$OUT_FILE"; fi
        if (( OPEN_HTML || OPEN_PDF )); then
          html_file=${OUT_FILE:-"/tmp/play.html"}
          css_readable='body{margin:2rem auto;max-width:800px;background:#fff;color:#222;font:16px/1.6 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;} h1,h2,strong{color:#111}'
          css_screenplay='body{margin:2rem auto;max-width:860px;background:#fff;color:#111;font:16px/1.6 Courier New,Courier,monospace} h1{letter-spacing:.5px}'
          css="$css_readable"; [[ "$LAYOUT" == "screenplay" ]] && css="$css_screenplay"
          { printf "<html><head><meta charset=\"utf-8\"><title>%s</title><style>%s</style></head><body><pre>" "$TITLE" "$css"; \
            printf "%s" "$doc" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'; \
            printf "</pre></body></html>"; } > "$html_file"
          if (( OPEN_PDF )) && command -v wkhtmltopdf >/dev/null 2>&1; then
            pdf_file=${OUT_FILE:-"/tmp/play"}; pdf_file=${pdf_file%.html}.pdf
            wkhtmltopdf "$html_file" "$pdf_file" >/dev/null 2>&1 || true
            if command -v open >/dev/null 2>&1; then open "$pdf_file"; fi
          else
            if command -v open >/dev/null 2>&1; then open "$html_file"; fi
          fi
        elif (( OPEN_NATIVE )); then
          file=${OUT_FILE:-"/tmp/play.md"}
          printf "%s\n" "$doc" > "$file"
          if command -v open >/dev/null 2>&1; then open "$file"; fi
        else
          printf "%s\n" "$doc"
        fi
        ;;
      *) echo "usage: fk read scene --act <I> --scene <II> [--format markdown|json]" ;;
    esac ;;
  help|--help|-h) help ;;
  *) help ;;
esac
